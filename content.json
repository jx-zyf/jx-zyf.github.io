{"meta":{"title":"linxun","subtitle":"linxunzyf","description":"林寻的博客","author":"linxunzyf","url":"https://jx-zyf.github.io"},"pages":[{"title":"about","date":"un22fin22","updated":"un55fin55","comments":true,"path":"about/index.html","permalink":"https://jx-zyf.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"un22fin22","updated":"un22fin22","comments":false,"path":"tags/index.html","permalink":"https://jx-zyf.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"un22fin22","updated":"un22fin22","comments":false,"path":"categories/index.html","permalink":"https://jx-zyf.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JS数组","slug":"数组","date":"un55fin55","updated":"un55fin55","comments":true,"path":"/posts/82c69460/","link":"","permalink":"https://jx-zyf.github.io/posts/82c69460/","excerpt":"","text":"写在开头在js中，数组应该是最常用的类型之一。并且，js中的数组和其他语言的数组有很大的区别。虽然都是有序列表，但是js中数组的每一项可以保存任何类型的值。也就是说，可以用数组的第一项来保存数值，第二项保存字符串，第三项保存对象，非常灵活。而且js数组的大小是具有呼吸性的，即可以随着数据的增加或删除自动改变length的大小。 常见的创建数组的方法有两种：一种是字面量语法，一种是使用Array构造函数创建。 var arr1 = []; // 创建了一个空数组 var arr2 = [1, 2, 3]; // 创建了一个包含3个数字的数组 var arr3 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; // 创建了一个包含3个字符串的数组 var arr4 = new Array(); // 创建了一个空数组 var arr5 = new Array(10); // 创建了一个length为10的数组，如果第一个参数不是数值，就会创建一个包含该项的数组 var arr6 = new Array(&apos;a&apos;, &apos;b&apos;) // 创建了一个包含两个字符串的数组 我们用的最多的还是第一种方法 常用方法检测数组 instanceof操作符：此方法基于原型/构造函数判断，只适用于只有一个全局环境的情况 arr instanceof Array; // 是数组返回true，否则返回false Array.prototype.isArray()：ES5新增，为了解决instanceof的问题，存在兼容性。IE9+，Firefox 4+，Safari 5+，Opera 10.5+和Chrome支持 arr.isArray(); // 是数组返回true，否则返回false 原型链：无兼容性 Object.prototype.toString.call(arr) === &apos;[object Array]&apos; 转换方法 Array.prototype.toString()：数组每一项转换成字符串并用’,’拼接成一个字符串 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].toString(); // a,b,c Array.prototype.join()：使用不同的分隔符构建这个字符串，默认使用’,’ [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].join(); // a,b,c [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].join(&apos;|&apos;); // a|b|c 栈方法（后进先出） Array.prototype.push()：接收任意数量的参数，将它们逐个添加到数组末尾，返回修改后数组的长度 Array.prototype.pop()：移除数组最后一项，并返回该项 var arr = [1, 2, 3] var length = arr.push(4, 5); console.log(arr, length); // [1, 2, 3, 4, 5], 5 var item = arr.pop(); console.log(arr, item); // [1, 2, 3, 4], 5 队列方法（先进先出） Array.prototype.push()：同上 Array.prototype.shift()：移除数组第一项，并返回该项 var arr = [] var length = arr.push(1, 2); console.log(arr, length); // [1, 2], 2 var item = arr.shift(); console.log(arr, item); // [2], 1 补充：Array.prototype.unshift()：接收任意数量的参数，将它们逐个添加到数组开头，返回修改后数组的长度 var arr = [1, 2, 3] var length = arr.unshift(4, 5); console.log(arr, length); // [4, 5, 1, 2, 3], 5 重排序方法 Array.prototype.reverse()：翻转数组顺序，会改变原数组 console.log([1, 2, 3].reverse()); // [3, 2, 1] Array.prototype.sort()：由于翻转不够灵活而出现，可以自定义排序规则，如果不传函数参数，则数组每一项调用toString()方法，然后排序；会改变原数组 var arr = [1, 15, 2, 30]; arr.sort(function(a, b) { return a-b; }); console.log(arr); // [1, 2, 15, 30] 操作方法 Array.prototype.concat()：先创建当前数组的一个副本，然后将接收到的参数添加到该副本的末尾。如果参数是一个或多个数组，会将这些数组的每一项添加到副本数组的末尾；如果不是数组，这些值就会简单的添加到副本数组的末尾；如果没传参数，就只是简单的创建一个副本。该方法返回这个新创建的副本数组，原数组不会改变。 var arr1 = [1, 2]; var arr2 = arr1.concat([3, 4], [5]); var arr3 = arr1.concat(3, 4); var arr4 = arr1.concat(); console.log(arr1); // [1, 2] console.log(arr2); // [1, 2, 3, 4, 5] console.log(arr3); // [1, 2, 3, 4] console.log(arr4); // [1, 2] Array.prototype.slice()：基于当前数组的一或多项创建一个新数组，即截取数组。接收两个参数，第一个参数（起始位置）必须，第二个参数（结束位置，不截取该项）可选，若不传则默认截取从开始位置到当前数组末尾所有项，即数组的length-1。该方法返回截取的新数组，不会改变原数组。 var arr1 = [1, 2, 3, 4]; var arr2 = arr1.slice(1); var arr3 = arr1.slice(1, 3); console.log(arr1); // [ 1, 2, 3, 4 ] console.log(arr2); // [ 2, 3, 4 ] console.log(arr3); // [ 2, 3 ] Array.prototype.splice()：最强大的数组操作方法，删除，插入，替换均可。接收多个参数，分别是操作位置，删除元素个数，新增的元素（可多个）；该方法返回删除元素组成的数组（如果没有删除元素则返回一个空数组），会改变原数组。 var arr1 = [1, 2, 3]; var arr2 = arr1.splice(1, 1); console.log(arr1); // [1, 3] console.log(arr2); // [2] var arr3 = arr1.splice(0, 0, 4, 5); console.log(arr1); // [4, 5, 1, 3] console.log(arr3); // [] var arr4 = arr1.splice(1, 1, 6); console.log(arr1); // [4, 6, 1, 3] console.log(arr4); // [5] 位置方法 Array.prototype.indexOf() Array.prototype.lastIndexOf()：这两个方法都接收两个参数，要查找的项（必须）和查找起点位置的索引（可选，包含该位置）；找到了返回该项在数组中的索引，否则返回-1。不同的是前者从前向后查找，后者从后向前查找。 var arr = [1, 2, 3, 4, 5, 6, 4, 2]; console.log(arr.indexOf(4)); // 3 console.log(arr.indexOf(4, 4)) // 6 console.log(arr.indexOf(4, 7)) // -1 console.log(arr.lastIndexOf(4)) // 6 console.log(arr.lastIndexOf(4, 4)) // 3 console.log(arr.lastIndexOf(4, 2)) // -1 迭代方法五个迭代方法：每个方法都接收两个参数，要在每一项上运行的函数（必须）和运行该函数的作用域对象（可选，影响this的值）。这个函数参数会接收三个参数，分别是迭代的每一项，该项的索引和数组对象本身。原数组都不会改变。 Array.prototype.every()：函数参数对每一项都返回true，则返回true，否则返回false。 Array.prototype.filter()：返回函数参数返回true的项组成的数组。 Array.prototype.forEach()：没有返回值。 Array.prototype.map()：返回每次调用函数参数的结果组成的数组。 Array.prototype.some()：函数参数对任何一项返回true，则返回true，否则返回false。 var arr = [1, 2, 3, 4, 5]; var result1 = arr.every(function(item, index, arr) { return (item &lt; 3); }); console.log(result1); // false var result2 = arr.some(function(item, index, arr) { return (item &lt; 3); }); console.log(result2); // true var result3 = arr.filter(function(item, index, arr) { return (item &lt; 3); }); console.log(result3); // [1, 2] var result4 = arr.map(function(item, index, arr) { return (item * 2) }); console.log(result4); // [2, 4, 6, 8, 10] arr.forEach(function(item, index, arr) { // 执行某些操作... }); 注意：函数参数的三个参数根据实际需要来确定是否接收，如不需要原数组对象，可以不接收。 缩小方法 Array.prototype.reduce()： Array.prototype.reduceRight()：这两个方法都接收两个参数，一个在每一项调用的函数（必须）和作为缩小基础的初始值（可选）。不会改变原数组，并且构建出一个最终的值作为返回值。函数参数接收四个参数：前一项，当前项，当前项索引和原数组对象。这个函数返回的任何值都会作为下次调用该函数时的第一个参数，即前一项。第一次调用该函数时当前项是数组的第二项（即索引为1），第一个参数则为第一项（索引为0）。这两个函数的区别是前者从第一项开始，逐个遍历到最后；后者从最后一项开始，逐个遍历到第一项。 var arr = [1, 2, 3, 4]; var result = arr.reduce(function(pre, cur, index, arr) { return (pre + cur); }); console.log(arr); // [1, 2, 3, 4] console.log(result); // 10 ES6新增 Array.from()：将类似数组的对象和可遍历的对象（包括ES6中的Set和Map）转化为真正的数组并返回该数组；字符串也能转化为数组 let arrayLike = { &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3 }; // es5 console.log(Array.prototype.slice.call(arrayLike, 0)); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] // es6 console.log(Array.from(arrayLike)) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] console.log(Array.from(&apos;hello&apos;)); // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] Array.from 方法还接受第二个参数，作用类似于数组的 map() 方法，用来对每个元素进行处理，将处理后的值放入返回的数组 let arrayLike = { &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, length: 3 }; console.log(Array.from(arrayLike, x =&gt; x * x)); // [1, 4, 9] // 等同于 console.log(Array.from(arrayLike).map(x =&gt; x * x)); // [1, 4, 9] Array.of()：将一组值转换为数组 Array.of(1,2,3); // [1, 2, 3] Array.of(3); // [3] Array.of(); // [] Array.of(1,,2,&apos;a&apos;); // error Array.of(1,2,&apos;a&apos;); // [1,2,&apos;a&apos;] Array.prototype.copyWithin()：在当前数组内部，将指定位置的成员，复制到其他位置（会覆盖原有成员，修改原数组），然后返回替换后的数组。该方法接收三个参数：（三个参数都是数值，如果不是会自动转化成数值）-target（必需）：从该位置开始替换数据-start（可选）：从该位置开始读取目标数据，默认值是0-end（可选）：从该位置（不包括它）停止读取目标数据，默认值是数组长度（将start到end的成员替换从target开始的成员） console.log([5, 3, 1, 8, 0, 2].copyWithin(3, 0, 2)); // [5, 3, 1, 5, 3, 2] Array.prototype.find(): 该方法接收一个函数作为参数，用于找出参数函数返回true的第一个数组成员（即满足条件的成员），没找到返回 undefined。该函数参数接收三个参数（value，index，arr），分别是当前值，当前位置和原数组。 Array.prototype.findIndex():该方法参数同find()，返回符合条件的第一个数组成员的索引，没找到返回 -1。 console.log([1, 2, 3, 4].find((x) =&gt; x &gt; 2)) // 3 console.log([1, 2, 3, 4].find((x) =&gt; x &gt; 4)) // undefined console.log([1, 2, 3, 4].findIndex((x) =&gt; x &gt; 2)) // 2 console.log([1, 2, 3, 4].findIndex((x) =&gt; x &gt; 4)) // -1 Array.prototype.fill()：使用指定的值，填充一个数组并返回，会改变原数组。接收三个参数：-value（必需）：填充的值-start（可选）：填充的起始位置，默认是0-end（可选）：填充的结束位置（不包括它），默认是数组的长度 var arr = [1, 2, 3, 4]; console.log(arr.fill(6)); // [6, 6, 6, 6] console.log(arr); // [6, 6, 6, 6] console.log(arr.fill(3,1,3)); // [6, 3, 3, 6] console.log(arr); // [6, 3, 3, 6] Array.prototype.entries()，Array.prototype.keys() 和 Array.prototype.values()：这三个方法都返回一个遍历器对象，可以用for...of循环遍历，区别是keys()是对键名的遍历，values()是对键值的遍历，entries()是对键值对的遍历。 for (let key of [1, 2].keys()) { console.log(key); // 0, 1 } for (let value of [1, 2].values()) { console.log(value); } for (let [key, value] of [1, 2].entries()) { console.log(key, value); // 0 1 , 1 2 } 注意：对于values()， Chrome 未实现，Firefox未实现，Edge已实现。 Array.prototype.includes()：该方法返回了一个布尔值，判断数组中是否包含给定的值，与字符串的 includes() 类似。该方法可以检测到 NaN，弥补了 indexOf() 的不足；并且 indexOf() 不够具有语义化，它检测的是在数组中的位置。它接收两个参数：-target（必需）：需要在数组中匹配的值-start（可选）：从该位置（包含该位置）开始匹配，默认为0。如果为负数则表示倒数的位置，如果大于数组长度则重置为0 console.log([1, 2, 3].includes(2)) // true console.log([1, 2, 3].includes(2, 2)) // false console.log([1, 2, 3].includes(2, -2)) // true 注意：该方法目前还存在兼容性 // 兼容性写法 const contains = (() =&gt; Array.prototype.includes ? (arr, value, index) =&gt; arr.includes(value, index) : (arr, value, index) =&gt; arr.some((el, index) =&gt; el === value) )(); console.log(contains([1,2,3], 1, 1)); // false 另外：Map 和 Set 数据结构有一个 has 方法，注意与 includes() 的区别：-Map：查找键名（key）-Set：查找键值（value） 参考：JavaScript高级程序设计（第三版） 阮一峰es6入门：数组的扩展 写在最后在如此多的数组方法中，非常容易记混。我认为要抓住以下几点：该方法的作用？所需的参数（必需的和可选的）有哪些？是否有返回值？返回值是什么？是否会改变原数组？","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jx-zyf.github.io/tags/JavaScript/"}]},{"title":"JavaScript基础","slug":"JavaScript原型，闭包及作用域","date":"un33fin33","updated":"un33fin33","comments":true,"path":"/posts/a9ba4134/","link":"","permalink":"https://jx-zyf.github.io/posts/a9ba4134/","excerpt":"","text":"原型在ES6之前，javascript是没有“类”的概念的，这是由于js诞生就是为了响应用户的交互，如果有了“类”，就成了一种完整的面向对象编程语言了。但是，js中都是对象，必须有一种机制，将所有对象联系起来，所以“继承”还是很有必要的。 new运算符我们都知道，C和Java都是通过new来生成实例的，于是js也使用了这个命令。在js中，new后面跟的不是原型对象，而是构造函数。 下面我们看段代码： function People(name) { this.name = name; this.say = function() { console.log(`I&apos;m ${this.name}`) } } let linxun = new People(&apos;linxun&apos;); linxun.say() // I&apos;m linxun 注意：this指的是新创建的实例对象 上面的例子中，People是构造函数，其中有一个name属性和一个say方法，每个实例的name属性是不一样的，say方法却是相同的，所以用new生成实例对象有一个很大的缺陷，就是不能实现共享属性和方法，每一个实例对象的属性和方法都是自身独有的，这是对资源极大的浪费。 扯了这么多，终于到重点了！ prototype属性的引入这个属性(只要函数才有)包含了一个对象(以下称为“prototype对象”)，所有实例需要共享的属性和方法，都放在这个对象上。而那些不需要共享的，实例独有的属性和方法就放在构造函数里面。实例创建之后，会自动引用prototype对象中的属性和方法。 还是刚才那个例子，我们改写一下： function People(name) { this.name = name; } People.prototype = { say: function() { console.log(`I&apos;m ${this.name}`); } } let linxun = new People(&apos;linxun&apos;); let zyf = new People(&apos;zyf); linxun.say() // I&apos;m linxun zyf.say() // I&apos;m zyf 现在say方法就是所有实例共享的了，如果修改了它，所有的实例对象都会受影响。 People.prototype.say = function() { console.log(&apos;我被修改了&apos;); } linxun.say() // 我被修改了 zyf.say() // 我被修改了 原型链的实现引用《JavaScript权威指南》中的一段描述 Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype. 我的理解就是每个js对象(null除外)都有一个原型对象，并且从原型对象上继承属性和方法。 既然有这么一个原型对象，那么我们的对象怎么和原型对象对应起来呢？对象的 __proto__ (以下称为“原型对象”) 属性就指向它构造函数的prototype(以下称为“原型”)，而对象的原型本身也是一个对象，也有 __proto__ 属性，这就形成了原型链。原型链的最顶端是 Object.prototype ，它的 __proto__ 指向null(ECMA规定的，避免无限循环)。 从前面我们知道，函数创建的时候就拥有了prototype属性，我们创建实例的时候依靠它实现属性和方法的继承。 这里插入一下，new操作符到底做了什么事情？ 创建一个空对象 var obj = {} 将创建对象的 __proto__ 指向构造函数的prototype obj.__proto__ = 构造函数.protootype 将对象内部的this指向新创建的对象 构造函数.call(obj) 还是看代码吧： var obj1 = {} var obj2 = new Object(); console.log(obj1.__proto__ === Object.prototype); // true console.log(obj2.__proto__ === Object.prototype); // true console.log(Object.prototype.__proto__ === null); // true 还是有点懵？看张图吧，我轻易不放出来。其实只是因为我很懒不想打这么多字…… 属性或方法的查找当查找一个对象的属性或方法时，js会向上遍历原型链，先在自身查找，没找到就到它原型对象上找，依次向上查找，直到原型链的最顶端Object.prototype，如果仍然没有找到，就返回undefined(不存在该属性)或者抛出一个错误(不存在该方法)。 闭包闭包是js的一大特色，也是一大难点。下面就是我对闭包的理解。 变量的作用域说起闭包，就不得不先了解下js特殊的变量作用域。js中变量作用域就两种：全局变量和局部变量。 全局变量：在任何地方都能访问 局部变量：只有在特定的地方才能访问 举个例子： var a = 10; function test() { var b = ‘hello world’; console.log(a, b); } test(); // 10, hello world console.log(a, b); // 10, error: b is not defined 上面例子中的 a 就是全局变量，在哪里都能访问；b 就是局部变量，只有在 test 函数中才能访问。注意：声明 b 变量时 var 不能省略，否则就声明了一个全局变量 如何从函数外部读取局部变量在很多时候，我们需要得到函数内部的局部变量，在正常情况下这是做不到的。我们可以这样，在函数中再声明一个函数。下面代码中，函数fun2中是可以访问fun1函数中的局部变量的，而反过来就不行。这就是js特殊的链式作用域，在下面我们会讲到这个问题。 function fun1() { var a = 10; function fun2() { console.log(a); // 10 } } 既然函数fun2可以读取函数fun1中的局部变量，如果我们将fun2作为fun1的返回值返回出去，那么我们不就可以在外面读取函数fun1的局部变量了吗？ function fun1() { var a = 10; return function() { console.log(a); } } var result = fun1(); result(); // 10 上面代码中，声明一个全局变量result来接收fun1的返回值(fun2)，意味着fun2将一直存在，而fun1作为fun2的依赖函数，也将一直存在作用域中。如果将result销毁，自然也就访问不到fun1中的局部变量了。 闭包的概念上面例子中的fun2就是闭包。参考阮一峰阮大神的文章：学习javascript闭包 闭包就是能够读取其他函数内部变量的函数 我的理解是：闭包是指有权访问另一个函数作用域中变量的函数。在A函数中声明定义B函数，且B函数中使用了A函数中的局部变量，这就是闭包。即使A函数调用完毕，B函数依然可以访问那个局部变量。如果A函数没有执行完，B函数中使用的局部变量的值是其当前值，如果A函数执行完毕，B函数中使用的局部变量就是最终值。 闭包的作用讲了那么多，闭包究竟有什么用呢？ 上面例子中的，读取函数内部的变量 让一个变量常驻内存，上面代码中的变量a就已经常驻内存了，只有通过我们手动销毁。 IIFE下面看一个例子：假设页面上有五个按钮，对每个按钮添加点击事件 var ele = document.getElementsByTagName(&apos;button&apos;); for(var i=0, l=ele.length; i&lt;l; i++) { ele[i].addEventListener(&apos;click&apos;, function() { console.log(i); }); } 上面代码打印出了五个5，而不是我们期待的0,1,2,3,4；因为 i 是全局变量自始至终就只有一个 i，点击事件执行时，循环早已经执行完毕，它闭包到的永远是 i 最后的值。而如果改写成下面这样： var ele = document.getElementsByTagName(&apos;button&apos;); for(var i=0, l=ele.length; i&lt;l; i++) { (function(j) { ele[i].addEventListener(&apos;click&apos;, function() { console.log(j); }); })(i) } 上面代码就打印出我们期待的0,1,2,3,4了；使用了IIFE立即执行函数创建了五个 i 的作用域，每个作用域中的 i 相互独立不受影响，避免了 i 的共用。 闭包的缺陷前面也提到了，闭包会使得函数中的变量一直保存在内存中，所以不能滥用闭包，否则会造成性能问题。解决方法是：在不需要该变量时手动清除。 作用域和作用域链js中变量的作用域分为全局作用域和局部作用域，作用域（执行环境）就是变量和函数的可访问范围。某个执行环境中所有代码执行完毕后，该环境就会被销毁，保存在其中的所有变量和函数定义也会被销毁，全局执行环境直到应用程序退出——如关闭网页或浏览器——时才会被销毁。 在任何地方都能访问到的对象拥有全局作用域，一般有以下几种情况： 最外层函数和在最外层函数外面定义的变量 未申明直接赋值的变量自动声明为全局作用域 所有window对象的属性 局部作用域只在固定的代码片段可以访问，最常见的如函数内部 ES6之前，js没有块级作用域 （ IIFE 实现块级作用域 let：es6） 作用域链：函数创建时有一个内部属性[[Scope]]，这个内部属性包含了函数创建时作用域中对象的集合，这个集合决定了哪些数据能被访问。 函数创建的时候，作用域链会填入一个全局对象，包含了所有全局变量 函数执行时会创建一个“运行期上下文”的内部对象，它定义了函数执行的环境。每个运行期上下文都有自己的作用域链 函数[[Scope]]属性中的集合被复制到运行期上下文对象上，组成了一个新的对象，称为“活动对象” 函数执行完毕后，运行期上下文被销毁，活动对象也随之销毁 今天就到这吧了……不定期更新","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jx-zyf.github.io/tags/JavaScript/"}]},{"title":"HTML&CSS基础知识（二）","slug":"HTML与CSS(2)","date":"un11fin11","updated":"un22fin22","comments":true,"path":"/posts/d8be64fd/","link":"","permalink":"https://jx-zyf.github.io/posts/d8be64fd/","excerpt":"","text":"HTML&amp;CSS1.盒子模型盒子模型都包含 content(内容)，padding(内边距/内填充)，margin(外边距/外填充)，border(边框) 标准盒子模型(content-box) 标准盒子模型是w3c盒子模型，从上图可以看出width/height的计算规则是只包含content部分 IE盒子模型(border-box) 从上图可以看出IE盒子模型的width/height计算包含border，padding和content 只要在HTML文件顶部有doctype声明，浏览器就会使用w3c的标准盒子模型；如果没有声明，则不同浏览器会使用不同的盒子模型去加载，如IE使用IE盒子模型，Chrome和Firefox会使用w3c标准盒子模型 在CSS3中，我们可以自己定义盒子模型(box-sizing) box-sizing 有两个值，一个是content-box(默认标准模型)，另一个是border-box(IE盒子模型，也加边框模型) 2.行内元素和块级元素行内元素和块级元素的区别： 1.行内元素会在一条直线上排列，而块级元素占据一行，在垂直方向上排列。 2.一般情况下(HTML5之前)，行内元素只能包含文本和其他行内元素，而块级元素可以包含行内元素和块级元素 按照新的HTML规范，已经不按inline和block来区分元素类型了 替换元素与非替换元素 从元素本身特点来讲，元素分为替换元素和非替换元素 替换元素：浏览器根据元素属性来决定元素具体显示的内容。比如说浏览器会根据 img 标签的src来读取图片信息，根据 input 标签的type来决定是输入框还是按钮等。HTML中的 img ，input ， select ， textarea 等都是替换元素，因为这些元素没有实际内容，浏览器根据标签类型或属性来显示这些元素 非替换元素：HTML中多数元素都是不可替换元素，其内容直接显示在浏览器上。接下来就是重点了：1.块级元素width/height/margin/padding的设置都有效2.行内替换元素width/height/margin/padding的设置都有效3.行内非替换元素width/height的设置无效，一般用line-height控制行高(大部分行内元素都是行内非替换元素，如span,a,i,label等)；margin的左右设置有效，上下设置无效；padding的上下左右设置我认为其实都有效，但是由于行高没有发生变化，元素的位置只相对于左右变化，而上下没有变化。 3.定位(position) static: 静态定位，默认(没有定位) relative: 绝对定位，相对元素本身定位，也就是相对于它本该存在的位置(正常位置)定位，位置通过 left / right / top / bottom 确定 absolute: 相对定位，相对该元素第一个不是static定位的父元素定位，位置通过 left / right / top / bottom 确定 fixed: 固定定位，相对浏览器窗口定位，位置通过 left / right / top / bottom 确定 inherit: 继承，从父元素继承position定位 定位会脱离文档流，父元素计算高度的时候不会将其计算进去 4.浮动(float)浮动的特点 浮动元素不会遮住其它元素内容，但是会遮住非浮动元素的布局 浮动元素的父元素在对内容进行排版展示时会忽略浮动子元素的存在(脱离文档流) 浮动元素会自动变成块级元素 清除浮动的方法 父元素设置overflow:hidden 父元素设置height 父元素定义伪类 :after 父元素结尾处加一个空标签：clear both 父元素也设置浮动，但是需要设置宽度… 5.css常用布局","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jx-zyf.github.io/tags/HTML/"}]},{"title":"HTML&CSS基础知识（一）","slug":"HTML与CSS","date":"un55fin55","updated":"un22fin22","comments":true,"path":"/posts/e8a88825/","link":"","permalink":"https://jx-zyf.github.io/posts/e8a88825/","excerpt":"","text":"HTML&amp;CSS1.主要浏览器有哪些？内核分别是什么？主流浏览器及内核： (1)Chrome：Webkit (2)IE：Trident (3)Safari：Webkit (4)Firefox:Gecko (5)Opera:Presto 2.DoctypeDOCTYPE是用来声明文档类型和DTD(document type definition,文档类型定义)规范的 HTML5只有一种&lt;!DOCTYPE&gt;声明 &lt;!DOCTYPE html&gt; HTML5不基于 SGML，所以不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。注意：&lt;!DOCTYPE&gt;不是HTML标签，没有结束标签，不区分大小写 3.浏览器模式浏览器模式分两种：(1).标准模式(standards mode)：浏览器根据标准规约来渲染页面 以下情况浏览器会采用标准模式渲染： 给出了完整的DOCTYPE声明DOCTYPE声明了Strict DTDDOCTYPE声明了Transitional DTD和URI (2).混杂/怪异/兼容模式(quirks mode)：浏览器采用更宽松的，向后兼容的方式来渲染页面 以下情况浏览器会采用混杂模式渲染： DOCTYPE声明了Transitional DTD但未给出URIDOCTYPE声明不合法 DTD未给出DOCTYPE声明混杂模式下，浏览器会模仿旧浏览器的行为 4.页面引入CSS样式时，link和@import的区别 link属于XHTML标签，除了加载CSS外，还能用于定义RSS，定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS；页面加载时，link引入的样式会同时被加载；而@import引入的样式只有在页面加载完才会被加载import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 5.浏览器渲染原理挂上大佬的博客，讲的很详细 深度剖析浏览器渲染性能原理，你到底知道多少？文章作者：齐修_qixiuss","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jx-zyf.github.io/tags/HTML/"}]},{"title":"About Me","slug":"About","date":"un66fin66","updated":"un22fin22","comments":true,"path":"/posts/f0b34752/","link":"","permalink":"https://jx-zyf.github.io/posts/f0b34752/","excerpt":"","text":"林寻丶我的微博 我是 林寻丶 热爱生活，热爱生命喜欢音乐，喜欢篮球的热血boy motto","categories":[{"name":"about","slug":"about","permalink":"https://jx-zyf.github.io/categories/about/"}],"tags":[]},{"title":"2017 in ShenZhen","slug":"Mylife","date":"un66fin66","updated":"un22fin22","comments":true,"path":"/posts/293f0615/","link":"","permalink":"https://jx-zyf.github.io/posts/293f0615/","excerpt":"","text":"深圳群居生活中…","categories":[{"name":"Mylife","slug":"Mylife","permalink":"https://jx-zyf.github.io/categories/Mylife/"}],"tags":[]}]}