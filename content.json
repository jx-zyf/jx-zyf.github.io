{"meta":{"title":"linxun","subtitle":"linxunzyf","description":"林寻的博客","author":"linxunzyf","url":"https://jx-zyf.github.io"},"pages":[{"title":"about","date":"un22fin22","updated":"un55fin55","comments":true,"path":"about/index.html","permalink":"https://jx-zyf.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"un22fin22","updated":"un22fin22","comments":false,"path":"categories/index.html","permalink":"https://jx-zyf.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"un22fin22","updated":"un22fin22","comments":false,"path":"tags/index.html","permalink":"https://jx-zyf.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue-music总结","slug":"vue-music总结","date":"un55fin55","updated":"un55fin55","comments":true,"path":"/posts/461d16ef/","link":"","permalink":"https://jx-zyf.github.io/posts/461d16ef/","excerpt":"","text":"由于本人比较喜欢听歌，所以这次跟着慕课网的实战课程做了这个项目。视频地址：Vue 2.0 高级实战-开发移动端音乐 WebApp 概述基于vue.js的音乐播放器，数据来源于QQ音乐。大部分接口都是JSONP，抓取较容易，其中有些接口限制了host，需要设置header，所以自己编写接口转发请求来绕过host的限制。具体代码参考build目录下dev-server.js 或者 prod.server.js。使用的技术栈：vue2.0+vuex+vue-router；另外使用了很多第三方插件。 启动项目源码12npm inpm start 效果预览 src目录─src │ App.vue │ main.js // 打包入口 ├─api // 数据抓取 ├─base // 基础可复用组件 ├─common // 共用字体，图片，js方法，样式等 ├─components // 业务组件 ├─router // 路由 └─store // 状态管理 数据处理由于很多JSONP请求，这里使用了一个第三方插件jsonp，这个插件使用很简单，有兴趣的可以学习一下。使用时，将请求的参数拼接到url上，调用他的jsonp方法即可。我们对请求回来的数据做了Promise化，方便我们后面使用数据。代码如下：1234567891011121314151617181920212223242526import originJSONP from 'jsonp'export default function jsonp(url, data, option) &#123; let subUrl = param(data).length &gt; 0 ? `?$&#123;param(data)&#125;` : '' url += subUrl return new Promise((resolve, reject) =&gt; &#123; originJSONP(url, option, (err, data) =&gt; &#123; if(!err) &#123; resolve(data) &#125; else &#123; reject(err) &#125; &#125;) &#125;)&#125;function param(data) &#123; let url = '' for(let p in data) &#123; let value = data[p] === undefined ? '' : data[p] url += `&amp;$&#123;p&#125;=$&#123;encodeURIComponent(value)&#125;` &#125; url = url.length &gt; 0 ? url.substring(1) : '' return url&#125; 播放器内核是这个项目的重点，vuex的设计非常重要，这里设计好了，后面的代码书写起来才更轻松。123456789101112singer: &#123;&#125;, // 当前歌手playing: false, // 播放状态fullScreen: false, // 播放器状态（全屏/迷你）playlist: [], // 播放列表（不同的播放模式不一样）sequenceList: [], // 播放列表（任何模式都一样）mode: playMode.sequence, // 播放模式（循环播放，单曲循环，随机播放）currentIndex: -1, // 当前歌曲在列表中的索引disc: &#123;&#125;, // 当前歌单topList: &#123;&#125;, // 当前排行榜searchHistory: loadSearch(),// 搜索历史playHistory: loadPlay(), // 播放历史likeList: loadLike() // 收藏列表 细节1.去除移动端点击事件300ms延迟，也是用的第三方插件，fastclick，文档在这里1fastclick.attach(document.body) 2.图片懒加载：项目中使用的是vue-lazyload，使用方法参考文档，代码如下：12345Vue.use(VueLazyload, &#123; preLoad: 1.3, loading: require('common/image/default.jpg'), attempt: 1&#125;) 然后在需要使用图片懒加载的地方使用v-lazy替代:src即可 3.项目中有很多业务逻辑多个组件是可以共用的，所以使用了mixins，具体可以参考官方文档 混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。 可以把它看做一个组件，它也是一个对象，可以把各个组件中的共用代码写在里面，然后在组件中引入即可。 4.项目中使用了很多audio的API，比如 timeupdate，play，ended 等。这都大大方便了我们的开发，比如 timeupdate 可以然我们准确得到当前播放的时间，进度条的实现就依赖这个方法。另外还要注意的是这里没有使用 canplay 而是使用了 play。我们设置了一个标志位songReady，当它为true的时候才能切换歌曲，如果我们将它设为true的时间是canplay的话，快速切换歌曲后点击暂停的话vuex中的状态虽然已经改变，但歌曲并没有停止播放。所以这里使用了play，只有当歌曲确实播放了才会将songReady置为true，这样即使点击再快也不会出现问题。 5.项目作者为了更好的交互体验，很多地方用到了滚动，上拉加载更多等。这里面用到了作者自己写的一个第三方库，better-scroll，确实很好用。很多地方也用到了vue的 transition 动画，比如页面之间的切换，播放器的打开和缩放到迷你播放器，这个动画比较好玩，用到了 transition 组件的几个事件：enter，after-enter，leave，after-leave。具体实现参考官方文档 6.路由懒加载：直接上文档吧！简单粗暴 7…… 最后确实用了好多插件啊！ 在这个项目中学到了很多，再次感受到组件化，模块化开发的方便，也遇到了很多问题，最后都解决了。继续爬行吧！少年！","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://jx-zyf.github.io/tags/vue/"}]},{"title":"react 实战总结","slug":"react-demo项目总结","date":"un22fin22","updated":"un22fin22","comments":true,"path":"/posts/68a33ea4/","link":"","permalink":"https://jx-zyf.github.io/posts/68a33ea4/","excerpt":"","text":"虽然不是第一次接触react，但之前都没有写博客记录，好记性不如烂笔头，希望以后养成多做笔记的好习惯吧。 关于react react 作为当下最流行的前端框架，之所以能被如此多前端开发者所喜爱自然是有原因的。react有一个很重要的特性——限制（Constraint），这里的“限制”并不是贬义，因为对于大部分开发者来说，代码的可维护性和扩展性并不是很好，所以只有施加“限制”，代码的管理才会更加简单。必须按照react的规范来写代码，不然程序就跑不了，就是这么霸道。 react 还有很多优势，个人认为最重要的就是虚拟DOM和组件化。 虚拟DOM：现在的框架很少有直接操作DOM的，虽然jQuery曾经称霸一方。当页面上的DOM树改变的时候，虚拟DOM机制会将前后DOM树进行对比（通过一些高效的算法），如果两个DOM树有不一样的地方，react只会针对不一样的地方进行修改，自然就提高了性能。举个栗子：现在的html结构是这样 12345&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; 你想让它变成这样123456&lt;ul&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt;&lt;/ul&gt; 如果是原始的DOM操作，你需要先将开始的三个li删除，然后再将后面的四个li添加进去；可能你也会这样操作：将三个li的innerHTML修改，只需要添加一个7就行了。那么恭喜你，做的很好。react有个很重要的思想，状态管理。只要DOM节点的对应的state发生了改变，react就会将其标注为“脏状态”，在一个Event loop结束后，对这些有标注的地方进行修改，并且只对修改了的地方重新渲染，减少了很多冗余的DOM操作。具体实现可以参考 深度剖析：如何实现一个 Virtual DOM 算法 组件化：简单的说下好处，可以模板化，可复用，可嵌套的UI模块，当然组件之间会存在依赖关系。可以将UI组件当作独立的js模块使用，推荐使用ES6的import来引用组件模块，当然也可以配合CommonJs、AMD、CMD等规范来require我们需要的组件模块，最重要的是处理好依赖关系。 项目前面说了这么多，终于到重点了。这个项目是参照慕课网实战视频做的，视频地址：React高级实战 打造大众点评 WebApp 启动： 123npm inpm run mocknpm start 项目预览 项目源码 项目目录 123456789101112131415161718192021222324252627282930313233343536373839404142│ package.json // 配置文件│ README.md├─build // 打包后的文件│├─config // 配置文件│├─mock // mock数据│ │ server.js // 请求数据接口│ ├─detail│ ├─home│ ├─public│ ├─search│ └─user│├─public│├─scripts│ build.js // 项目打包入口│ start.js // 项目启动入口│ test.js│└─src │ config.js // 常量配置 │ index.js // 程序入口 │ index.less │ ├─actions // actions │ ├─components // 木偶组件 │ ├─containers // 智能组件，与redux连接 │ ├─fetch // 获取数据 │ ├─reducers // reducers │ ├─router │ index.jsx // 前端路由 │ ├─static // 静态资源 │ └─util // 工具函数 webpack配置首先，项目采用 create-react-app 脚手架搭建，很多配置都已经帮我们写好了，但是仍需要自定义一些配置，所以我 npm run eject。对于这个命令，官方是这样解释的： Note: this is a one-way operation. Once you eject, you can’t go back! If you aren’t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. Instead, it will copy all the configuration files and the transitive dependencies (Webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own. You don’t have to ever use eject. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it. 这个项目我使用less编译css样式文件，所以需要添加配置：1234567891011121314151617181920212223242526272829303132333435&#123; test: /\\.(css|less)$/, use: [ require.resolve('style-loader'), &#123; loader: require.resolve('css-loader'), options: &#123; importLoaders: 1, &#125;, &#125;, &#123; loader: require.resolve('postcss-loader'), options: &#123; // Necessary for external CSS imports to work // https://github.com/facebookincubator/create-react-app/issues/2677 ident: 'postcss', plugins: () =&gt; [ require('postcss-flexbugs-fixes'), autoprefixer(&#123; browsers: [ '&gt;1%', 'last 4 versions', 'Firefox ESR', 'not ie &lt; 9', // React doesn't support IE8 anyway ], flexbox: 'no-2009', &#125;), ], &#125;, &#125;, &#123; loader: require.resolve('less-loader') // compiles Less to CSS &#125;, ],&#125;, 在开发环境和产品环境都需要配置，即在webpack.config.dev.js和webpack.config.prod.js都需要配置 前端路由配置然后就是前端页面路由配置，视频使用的是react-router2.0的版本，我用的是4.0版本，接触过的都知道，这两者差异很大。 history 不用props传递，使用HashRouter Route 不能嵌套使用，都在同一层级 想要匹配所有不存在的路由，就不传path 动态参数 :param 可选参数 :param? 精确匹配 exact 代码如下：12345678910111213import &#123; HashRouter, Route, Switch &#125; from 'react-router-dom'&lt;HashRouter&gt; &lt;Switch&gt; &lt;Route path='/' exact component=&#123;Home&#125; /&gt; &lt;Route path='/city' component=&#123;City&#125;/&gt; &lt;Route path='/search/:category/:keyword' component=&#123;Search&#125;/&gt; &lt;Route path='/detail/:id' component=&#123;Detail&#125;/&gt; &lt;Route path='/login' component=&#123;Login&#125;/&gt; &lt;Route path='/user' component=&#123;User&#125;/&gt; &lt;Route component=&#123;NotFound&#125;/&gt; &lt;/Switch&gt;&lt;/HashRouter&gt; 服务器配置我这里使用的koa2.0来做后端接口的模拟 由于我们的数据是采用静态数据模拟的，所以请求数据其实就是请求js文件，并将数据返回 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129const Koa = require('koa')const Router = require('koa-router')const path = require('path')const static = require('koa-static')const cors = require('koa2-cors');const bodyParser = require('koa-body')();const app = new Koa()const router = new Router()// 跨域app.use(cors(&#123; credentials: true, allowMethods: ['GET', 'POST', 'DELETE'], allowHeaders: ['Content-Type', 'Authorization', 'Accept'],&#125;))// 访问静态资源app.use(static( path.join(__dirname, '/public')))// 主页广告router.get('/data/homead', async (ctx) =&gt; &#123; ctx.body = require('./home/ad')&#125;)// 主页列表const homeListData = require('./home/list')router.get('/data/homelist/:cityname/:page', async (ctx) =&gt; &#123; const pageSize = 1 const &#123; cityname, page &#125; = ctx.params let filterData = homeListData.filter(item =&gt; item.cityname === cityname ) let hasMore = pageSize * page &gt;= filterData.length ? false : true ctx.body = &#123; result: filterData.slice(0, page * pageSize), hasMore: hasMore &#125;&#125;)// 搜索页列表const searchListData = require('./search/list')router.get('/data/search/:cityname/:category/:keyword/:page', async (ctx) =&gt; &#123; const pageSize = 1 const &#123; cityname, category, keyword, page &#125; = ctx.params let filterData let filterData1 = searchListData.filter(item =&gt; item.cityname === cityname ) if (keyword === 'all') &#123; filterData = filterData1.filter(item =&gt; item.category.includes(category) ) &#125; else &#123; filterData = filterData1.filter(item =&gt; item.title.includes(keyword) || item.subTitle.includes(keyword) ) &#125; let hasMore = pageSize * page &gt;= filterData.length ? false : true ctx.body = &#123; result: filterData.slice(0, page * pageSize), hasMore: hasMore &#125;&#125;)// 详情页 商家详情const detailData = require('./detail/info')router.get('/data/detail/info/:id', async (ctx) =&gt; &#123; let &#123; id &#125; = ctx.params id = parseInt(id) const filterData = detailData.filter(item =&gt; item.id === id ) ctx.body = filterData&#125;)// 详情页 评论列表const CommentData = require('./detail/comment')router.get('/data/detail/comment/:id/:page', async (ctx) =&gt; &#123; const pageSize = 2 const &#123; id, page &#125; = ctx.params let filterData = CommentData let hasMore = pageSize * page &gt;= filterData.length ? false : true ctx.body = &#123; result: filterData.slice(0, page * pageSize), hasMore: hasMore &#125;&#125;)// 登录router.post('/data/login', bodyParser, async (ctx) =&gt; &#123; const &#123; username, password &#125; = ctx.request.body if (username === 'linxun' &amp;&amp; password === 'linxun') &#123; ctx.body = &#123; status: 1, msg: '登录成功' &#125; &#125; else &#123; ctx.body = &#123; status: 0, msg: '用户名或密码错误' &#125; &#125;&#125;)// 收藏router.get('/data/collect/:id', async (ctx) =&gt; &#123; let &#123; id &#125; = ctx.params id = parseInt(id, 10) const filterData = detailData.filter(item =&gt; item.id === id ) ctx.body = filterData&#125;)// 订单const orderListData = require('./user/orderList')router.get('/data/orderList', async (ctx) =&gt; &#123; ctx.body = orderListData&#125;)// 加载路由中间件app.use(router.routes()).use(router.allowedMethods())app.listen(8000, () =&gt; &#123; console.log('route-use-middleware is starting at port 8000')&#125;) 前端数据请求由于我们的数据是采用静态数据模拟的，所以请求数据其实就是请求js文件，并将数据返回 这里使用fetch和promise，在组件中只需要发送请求，然后在.then()中即可拿到需要的数据 代码如下：123456789101112131415161718192021222324252627282930import 'whatwg-fetch'import 'es6-promise'export function get(url) &#123; return fetch(url, &#123; headers: &#123; 'Accept': 'application/json, text/plain, */*', &#125; &#125;)&#125;export function post(url, paramsObj) &#123; return fetch(url, &#123; method: 'POST', headers: &#123; 'Accept': 'application/json, text/plain, */*', 'Content-Type': 'application/x-www-form-urlencoded' &#125;, body: obj2params(paramsObj) &#125;);&#125;function obj2params(obj) &#123; let result = '', item; for (item in obj) &#123; result += '&amp;' + item + '=' + encodeURIComponent(obj[item]); &#125; result = result.length &gt; 0 ? result.slice(1) : result; return result;&#125; react与redux连接在智能组件中 代码如下：12345678910function mapStateToProps(state) &#123; return &#123; ... &#125; // 需要的仓库中的数据&#125;import &#123; bindActionCreators &#125; from 'redux'function mapDispatchToProps(dispatch) &#123; // actionCreater：只负责生成action (一个普通对象：必须包含type，其他自定义) return &#123; actionCreater: bindActionCreators(actionCreater, dispatch) &#125; &#125; 主要的代码就是这些，样式和素材都是视频中的。","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"react","slug":"react","permalink":"https://jx-zyf.github.io/tags/react/"}]},{"title":"JS数组","slug":"数组","date":"un55fin55","updated":"un55fin55","comments":true,"path":"/posts/82c69460/","link":"","permalink":"https://jx-zyf.github.io/posts/82c69460/","excerpt":"","text":"写在开头在js中，数组应该是最常用的类型之一。并且，js中的数组和其他语言的数组有很大的区别。虽然都是有序列表，但是js中数组的每一项可以保存任何类型的值。也就是说，可以用数组的第一项来保存数值，第二项保存字符串，第三项保存对象，非常灵活。而且js数组的大小是具有呼吸性的，即可以随着数据的增加或删除自动改变length的大小。 常见的创建数组的方法有两种：一种是字面量语法，一种是使用Array构造函数创建。 var arr1 = []; // 创建了一个空数组 var arr2 = [1, 2, 3]; // 创建了一个包含3个数字的数组 var arr3 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]; // 创建了一个包含3个字符串的数组 var arr4 = new Array(); // 创建了一个空数组 var arr5 = new Array(10); // 创建了一个length为10的数组，如果第一个参数不是数值，就会创建一个包含该项的数组 var arr6 = new Array(&apos;a&apos;, &apos;b&apos;) // 创建了一个包含两个字符串的数组 我们用的最多的还是第一种方法 常用方法检测数组 instanceof操作符：此方法基于原型/构造函数判断，只适用于只有一个全局环境的情况 arr instanceof Array; // 是数组返回true，否则返回false Array.prototype.isArray()：ES5新增，为了解决instanceof的问题，存在兼容性。IE9+，Firefox 4+，Safari 5+，Opera 10.5+和Chrome支持 arr.isArray(); // 是数组返回true，否则返回false 原型链：无兼容性 Object.prototype.toString.call(arr) === &apos;[object Array]&apos; 转换方法 Array.prototype.toString()：数组每一项转换成字符串并用’,’拼接成一个字符串 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].toString(); // a,b,c Array.prototype.join()：使用不同的分隔符构建这个字符串，默认使用’,’ [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].join(); // a,b,c [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].join(&apos;|&apos;); // a|b|c 栈方法（后进先出） Array.prototype.push()：接收任意数量的参数，将它们逐个添加到数组末尾，返回修改后数组的长度 Array.prototype.pop()：移除数组最后一项，并返回该项 var arr = [1, 2, 3] var length = arr.push(4, 5); console.log(arr, length); // [1, 2, 3, 4, 5], 5 var item = arr.pop(); console.log(arr, item); // [1, 2, 3, 4], 5 队列方法（先进先出） Array.prototype.push()：同上 Array.prototype.shift()：移除数组第一项，并返回该项 var arr = [] var length = arr.push(1, 2); console.log(arr, length); // [1, 2], 2 var item = arr.shift(); console.log(arr, item); // [2], 1 补充：Array.prototype.unshift()：接收任意数量的参数，将它们逐个添加到数组开头，返回修改后数组的长度 var arr = [1, 2, 3] var length = arr.unshift(4, 5); console.log(arr, length); // [4, 5, 1, 2, 3], 5 重排序方法 Array.prototype.reverse()：翻转数组顺序，会改变原数组 console.log([1, 2, 3].reverse()); // [3, 2, 1] Array.prototype.sort()：由于翻转不够灵活而出现，可以自定义排序规则，如果不传函数参数，则数组每一项调用toString()方法，然后排序；会改变原数组 var arr = [1, 15, 2, 30]; arr.sort(function(a, b) { return a-b; }); console.log(arr); // [1, 2, 15, 30] 操作方法 Array.prototype.concat()：先创建当前数组的一个副本，然后将接收到的参数添加到该副本的末尾。如果参数是一个或多个数组，会将这些数组的每一项添加到副本数组的末尾；如果不是数组，这些值就会简单的添加到副本数组的末尾；如果没传参数，就只是简单的创建一个副本。该方法返回这个新创建的副本数组，原数组不会改变。 var arr1 = [1, 2]; var arr2 = arr1.concat([3, 4], [5]); var arr3 = arr1.concat(3, 4); var arr4 = arr1.concat(); console.log(arr1); // [1, 2] console.log(arr2); // [1, 2, 3, 4, 5] console.log(arr3); // [1, 2, 3, 4] console.log(arr4); // [1, 2] Array.prototype.slice()：基于当前数组的一或多项创建一个新数组，即截取数组。接收两个参数，第一个参数（起始位置）必须，第二个参数（结束位置，不截取该项）可选，若不传则默认截取从开始位置到当前数组末尾所有项，即数组的length-1。该方法返回截取的新数组，不会改变原数组。 var arr1 = [1, 2, 3, 4]; var arr2 = arr1.slice(1); var arr3 = arr1.slice(1, 3); console.log(arr1); // [ 1, 2, 3, 4 ] console.log(arr2); // [ 2, 3, 4 ] console.log(arr3); // [ 2, 3 ] Array.prototype.splice()：最强大的数组操作方法，删除，插入，替换均可。接收多个参数，分别是操作位置，删除元素个数，新增的元素（可多个）；该方法返回删除元素组成的数组（如果没有删除元素则返回一个空数组），会改变原数组。 var arr1 = [1, 2, 3]; var arr2 = arr1.splice(1, 1); console.log(arr1); // [1, 3] console.log(arr2); // [2] var arr3 = arr1.splice(0, 0, 4, 5); console.log(arr1); // [4, 5, 1, 3] console.log(arr3); // [] var arr4 = arr1.splice(1, 1, 6); console.log(arr1); // [4, 6, 1, 3] console.log(arr4); // [5] 位置方法 Array.prototype.indexOf() Array.prototype.lastIndexOf()：这两个方法都接收两个参数，要查找的项（必须）和查找起点位置的索引（可选，包含该位置）；找到了返回该项在数组中的索引，否则返回-1。不同的是前者从前向后查找，后者从后向前查找。 var arr = [1, 2, 3, 4, 5, 6, 4, 2]; console.log(arr.indexOf(4)); // 3 console.log(arr.indexOf(4, 4)) // 6 console.log(arr.indexOf(4, 7)) // -1 console.log(arr.lastIndexOf(4)) // 6 console.log(arr.lastIndexOf(4, 4)) // 3 console.log(arr.lastIndexOf(4, 2)) // -1 迭代方法五个迭代方法：每个方法都接收两个参数，要在每一项上运行的函数（必须）和运行该函数的作用域对象（可选，影响this的值）。这个函数参数会接收三个参数，分别是迭代的每一项，该项的索引和数组对象本身。原数组都不会改变。 Array.prototype.every()：函数参数对每一项都返回true，则返回true，否则返回false。 Array.prototype.filter()：返回函数参数返回true的项组成的数组。 Array.prototype.forEach()：没有返回值。 Array.prototype.map()：返回每次调用函数参数的结果组成的数组。 Array.prototype.some()：函数参数对任何一项返回true，则返回true，否则返回false。 var arr = [1, 2, 3, 4, 5]; var result1 = arr.every(function(item, index, arr) { return (item &lt; 3); }); console.log(result1); // false var result2 = arr.some(function(item, index, arr) { return (item &lt; 3); }); console.log(result2); // true var result3 = arr.filter(function(item, index, arr) { return (item &lt; 3); }); console.log(result3); // [1, 2] var result4 = arr.map(function(item, index, arr) { return (item * 2) }); console.log(result4); // [2, 4, 6, 8, 10] arr.forEach(function(item, index, arr) { // 执行某些操作... }); 注意：函数参数的三个参数根据实际需要来确定是否接收，如不需要原数组对象，可以不接收。 缩小方法 Array.prototype.reduce()： Array.prototype.reduceRight()：这两个方法都接收两个参数，一个在每一项调用的函数（必须）和作为缩小基础的初始值（可选）。不会改变原数组，并且构建出一个最终的值作为返回值。函数参数接收四个参数：前一项，当前项，当前项索引和原数组对象。这个函数返回的任何值都会作为下次调用该函数时的第一个参数，即前一项。第一次调用该函数时当前项是数组的第二项（即索引为1），第一个参数则为第一项（索引为0）。这两个函数的区别是前者从第一项开始，逐个遍历到最后；后者从最后一项开始，逐个遍历到第一项。 var arr = [1, 2, 3, 4]; var result = arr.reduce(function(pre, cur, index, arr) { return (pre + cur); }); console.log(arr); // [1, 2, 3, 4] console.log(result); // 10 ES6新增 Array.from()：将类似数组的对象和可遍历的对象（包括ES6中的Set和Map）转化为真正的数组并返回该数组；字符串也能转化为数组 let arrayLike = { &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3 }; // es5 console.log(Array.prototype.slice.call(arrayLike, 0)); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] // es6 console.log(Array.from(arrayLike)) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] console.log(Array.from(&apos;hello&apos;)); // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;] Array.from 方法还接受第二个参数，作用类似于数组的 map() 方法，用来对每个元素进行处理，将处理后的值放入返回的数组 let arrayLike = { &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, length: 3 }; console.log(Array.from(arrayLike, x =&gt; x * x)); // [1, 4, 9] // 等同于 console.log(Array.from(arrayLike).map(x =&gt; x * x)); // [1, 4, 9] Array.of()：将一组值转换为数组 Array.of(1,2,3); // [1, 2, 3] Array.of(3); // [3] Array.of(); // [] Array.of(1,,2,&apos;a&apos;); // error Array.of(1,2,&apos;a&apos;); // [1,2,&apos;a&apos;] Array.prototype.copyWithin()：在当前数组内部，将指定位置的成员，复制到其他位置（会覆盖原有成员，修改原数组），然后返回替换后的数组。该方法接收三个参数：（三个参数都是数值，如果不是会自动转化成数值）-target（必需）：从该位置开始替换数据-start（可选）：从该位置开始读取目标数据，默认值是0-end（可选）：从该位置（不包括它）停止读取目标数据，默认值是数组长度（将start到end的成员替换从target开始的成员） console.log([5, 3, 1, 8, 0, 2].copyWithin(3, 0, 2)); // [5, 3, 1, 5, 3, 2] Array.prototype.find(): 该方法接收一个函数作为参数，用于找出参数函数返回true的第一个数组成员（即满足条件的成员），没找到返回 undefined。该函数参数接收三个参数（value，index，arr），分别是当前值，当前位置和原数组。 Array.prototype.findIndex():该方法参数同find()，返回符合条件的第一个数组成员的索引，没找到返回 -1。 console.log([1, 2, 3, 4].find((x) =&gt; x &gt; 2)) // 3 console.log([1, 2, 3, 4].find((x) =&gt; x &gt; 4)) // undefined console.log([1, 2, 3, 4].findIndex((x) =&gt; x &gt; 2)) // 2 console.log([1, 2, 3, 4].findIndex((x) =&gt; x &gt; 4)) // -1 Array.prototype.fill()：使用指定的值，填充一个数组并返回，会改变原数组。接收三个参数：-value（必需）：填充的值-start（可选）：填充的起始位置，默认是0-end（可选）：填充的结束位置（不包括它），默认是数组的长度 var arr = [1, 2, 3, 4]; console.log(arr.fill(6)); // [6, 6, 6, 6] console.log(arr); // [6, 6, 6, 6] console.log(arr.fill(3,1,3)); // [6, 3, 3, 6] console.log(arr); // [6, 3, 3, 6] Array.prototype.entries()，Array.prototype.keys() 和 Array.prototype.values()：这三个方法都返回一个遍历器对象，可以用for...of循环遍历，区别是keys()是对键名的遍历，values()是对键值的遍历，entries()是对键值对的遍历。 for (let key of [1, 2].keys()) { console.log(key); // 0, 1 } for (let value of [1, 2].values()) { console.log(value); } for (let [key, value] of [1, 2].entries()) { console.log(key, value); // 0 1 , 1 2 } 注意：对于values()， Chrome 未实现，Firefox未实现，Edge已实现。 Array.prototype.includes()：该方法返回了一个布尔值，判断数组中是否包含给定的值，与字符串的 includes() 类似。该方法可以检测到 NaN，弥补了 indexOf() 的不足；并且 indexOf() 不够具有语义化，它检测的是在数组中的位置。它接收两个参数：-target（必需）：需要在数组中匹配的值-start（可选）：从该位置（包含该位置）开始匹配，默认为0。如果为负数则表示倒数的位置，如果大于数组长度则重置为0 console.log([1, 2, 3].includes(2)) // true console.log([1, 2, 3].includes(2, 2)) // false console.log([1, 2, 3].includes(2, -2)) // true 注意：该方法目前还存在兼容性 // 兼容性写法 const contains = (() =&gt; Array.prototype.includes ? (arr, value, index) =&gt; arr.includes(value, index) : (arr, value, index) =&gt; arr.some((el, index) =&gt; el === value) )(); console.log(contains([1,2,3], 1, 1)); // false 另外：Map 和 Set 数据结构有一个 has 方法，注意与 includes() 的区别：-Map：查找键名（key）-Set：查找键值（value） 参考：JavaScript高级程序设计（第三版） 阮一峰es6入门：数组的扩展 写在最后在如此多的数组方法中，非常容易记混。我认为要抓住以下几点：该方法的作用？所需的参数（必需的和可选的）有哪些？是否有返回值？返回值是什么？是否会改变原数组？","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jx-zyf.github.io/tags/JavaScript/"}]},{"title":"JavaScript基础","slug":"JavaScript原型，闭包及作用域","date":"un33fin33","updated":"un33fin33","comments":true,"path":"/posts/a9ba4134/","link":"","permalink":"https://jx-zyf.github.io/posts/a9ba4134/","excerpt":"","text":"原型在ES6之前，javascript是没有“类”的概念的，这是由于js诞生就是为了响应用户的交互，如果有了“类”，就成了一种完整的面向对象编程语言了。但是，js中都是对象，必须有一种机制，将所有对象联系起来，所以“继承”还是很有必要的。 new运算符我们都知道，C和Java都是通过new来生成实例的，于是js也使用了这个命令。在js中，new后面跟的不是原型对象，而是构造函数。 下面我们看段代码： function People(name) { this.name = name; this.say = function() { console.log(`I&apos;m ${this.name}`) } } let linxun = new People(&apos;linxun&apos;); linxun.say() // I&apos;m linxun 注意：this指的是新创建的实例对象 上面的例子中，People是构造函数，其中有一个name属性和一个say方法，每个实例的name属性是不一样的，say方法却是相同的，所以用new生成实例对象有一个很大的缺陷，就是不能实现共享属性和方法，每一个实例对象的属性和方法都是自身独有的，这是对资源极大的浪费。 扯了这么多，终于到重点了！ prototype属性的引入这个属性(只要函数才有)包含了一个对象(以下称为“prototype对象”)，所有实例需要共享的属性和方法，都放在这个对象上。而那些不需要共享的，实例独有的属性和方法就放在构造函数里面。实例创建之后，会自动引用prototype对象中的属性和方法。 还是刚才那个例子，我们改写一下： function People(name) { this.name = name; } People.prototype = { say: function() { console.log(`I&apos;m ${this.name}`); } } let linxun = new People(&apos;linxun&apos;); let zyf = new People(&apos;zyf); linxun.say() // I&apos;m linxun zyf.say() // I&apos;m zyf 现在say方法就是所有实例共享的了，如果修改了它，所有的实例对象都会受影响。 People.prototype.say = function() { console.log(&apos;我被修改了&apos;); } linxun.say() // 我被修改了 zyf.say() // 我被修改了 原型链的实现引用《JavaScript权威指南》中的一段描述 Every JavaScript object has a second JavaScript object (or null ,but this is rare) associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype. 我的理解就是每个js对象(null除外)都有一个原型对象，并且从原型对象上继承属性和方法。 既然有这么一个原型对象，那么我们的对象怎么和原型对象对应起来呢？对象的 __proto__ (以下称为“原型对象”) 属性就指向它构造函数的prototype(以下称为“原型”)，而对象的原型本身也是一个对象，也有 __proto__ 属性，这就形成了原型链。原型链的最顶端是 Object.prototype ，它的 __proto__ 指向null(ECMA规定的，避免无限循环)。 从前面我们知道，函数创建的时候就拥有了prototype属性，我们创建实例的时候依靠它实现属性和方法的继承。 这里插入一下，new操作符到底做了什么事情？ 创建一个空对象 var obj = {} 将创建对象的 __proto__ 指向构造函数的prototype obj.__proto__ = 构造函数.protootype 将对象内部的this指向新创建的对象 构造函数.call(obj) 还是看代码吧： var obj1 = {} var obj2 = new Object(); console.log(obj1.__proto__ === Object.prototype); // true console.log(obj2.__proto__ === Object.prototype); // true console.log(Object.prototype.__proto__ === null); // true 还是有点懵？看张图吧，我轻易不放出来。其实只是因为我很懒不想打这么多字…… 属性或方法的查找当查找一个对象的属性或方法时，js会向上遍历原型链，先在自身查找，没找到就到它原型对象上找，依次向上查找，直到原型链的最顶端Object.prototype，如果仍然没有找到，就返回undefined(不存在该属性)或者抛出一个错误(不存在该方法)。 闭包闭包是js的一大特色，也是一大难点。下面就是我对闭包的理解。 变量的作用域说起闭包，就不得不先了解下js特殊的变量作用域。js中变量作用域就两种：全局变量和局部变量。 全局变量：在任何地方都能访问 局部变量：只有在特定的地方才能访问 举个例子： var a = 10; function test() { var b = ‘hello world’; console.log(a, b); } test(); // 10, hello world console.log(a, b); // 10, error: b is not defined 上面例子中的 a 就是全局变量，在哪里都能访问；b 就是局部变量，只有在 test 函数中才能访问。注意：声明 b 变量时 var 不能省略，否则就声明了一个全局变量 如何从函数外部读取局部变量在很多时候，我们需要得到函数内部的局部变量，在正常情况下这是做不到的。我们可以这样，在函数中再声明一个函数。下面代码中，函数fun2中是可以访问fun1函数中的局部变量的，而反过来就不行。这就是js特殊的链式作用域，在下面我们会讲到这个问题。 function fun1() { var a = 10; function fun2() { console.log(a); // 10 } } 既然函数fun2可以读取函数fun1中的局部变量，如果我们将fun2作为fun1的返回值返回出去，那么我们不就可以在外面读取函数fun1的局部变量了吗？ function fun1() { var a = 10; return function() { console.log(a); } } var result = fun1(); result(); // 10 上面代码中，声明一个全局变量result来接收fun1的返回值(fun2)，意味着fun2将一直存在，而fun1作为fun2的依赖函数，也将一直存在作用域中。如果将result销毁，自然也就访问不到fun1中的局部变量了。 闭包的概念上面例子中的fun2就是闭包。参考阮一峰阮大神的文章：学习javascript闭包 闭包就是能够读取其他函数内部变量的函数 我的理解是：闭包是指有权访问另一个函数作用域中变量的函数。在A函数中声明定义B函数，且B函数中使用了A函数中的局部变量，这就是闭包。即使A函数调用完毕，B函数依然可以访问那个局部变量。如果A函数没有执行完，B函数中使用的局部变量的值是其当前值，如果A函数执行完毕，B函数中使用的局部变量就是最终值。 闭包的作用讲了那么多，闭包究竟有什么用呢？ 上面例子中的，读取函数内部的变量 让一个变量常驻内存，上面代码中的变量a就已经常驻内存了，只有通过我们手动销毁。 IIFE下面看一个例子：假设页面上有五个按钮，对每个按钮添加点击事件 var ele = document.getElementsByTagName(&apos;button&apos;); for(var i=0, l=ele.length; i&lt;l; i++) { ele[i].addEventListener(&apos;click&apos;, function() { console.log(i); }); } 上面代码打印出了五个5，而不是我们期待的0,1,2,3,4；因为 i 是全局变量自始至终就只有一个 i，点击事件执行时，循环早已经执行完毕，它闭包到的永远是 i 最后的值。而如果改写成下面这样： var ele = document.getElementsByTagName(&apos;button&apos;); for(var i=0, l=ele.length; i&lt;l; i++) { (function(j) { ele[i].addEventListener(&apos;click&apos;, function() { console.log(j); }); })(i) } 上面代码就打印出我们期待的0,1,2,3,4了；使用了IIFE立即执行函数创建了五个 i 的作用域，每个作用域中的 i 相互独立不受影响，避免了 i 的共用。 闭包的缺陷前面也提到了，闭包会使得函数中的变量一直保存在内存中，所以不能滥用闭包，否则会造成性能问题。解决方法是：在不需要该变量时手动清除。 作用域和作用域链js中变量的作用域分为全局作用域和局部作用域，作用域（执行环境）就是变量和函数的可访问范围。某个执行环境中所有代码执行完毕后，该环境就会被销毁，保存在其中的所有变量和函数定义也会被销毁，全局执行环境直到应用程序退出——如关闭网页或浏览器——时才会被销毁。 在任何地方都能访问到的对象拥有全局作用域，一般有以下几种情况： 最外层函数和在最外层函数外面定义的变量 未申明直接赋值的变量自动声明为全局作用域 所有window对象的属性 局部作用域只在固定的代码片段可以访问，最常见的如函数内部 ES6之前，js没有块级作用域 （ IIFE 实现块级作用域 let：es6） 作用域链：函数创建时有一个内部属性[[Scope]]，这个内部属性包含了函数创建时作用域中对象的集合，这个集合决定了哪些数据能被访问。 函数创建的时候，作用域链会填入一个全局对象，包含了所有全局变量 函数执行时会创建一个“运行期上下文”的内部对象，它定义了函数执行的环境。每个运行期上下文都有自己的作用域链 函数[[Scope]]属性中的集合被复制到运行期上下文对象上，组成了一个新的对象，称为“活动对象” 函数执行完毕后，运行期上下文被销毁，活动对象也随之销毁 今天就到这吧了……不定期更新","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jx-zyf.github.io/tags/JavaScript/"}]},{"title":"HTML&CSS基础知识（二）","slug":"HTML与CSS(2)","date":"un11fin11","updated":"un22fin22","comments":true,"path":"/posts/d8be64fd/","link":"","permalink":"https://jx-zyf.github.io/posts/d8be64fd/","excerpt":"","text":"HTML&amp;CSS1.盒子模型盒子模型都包含 content(内容)，padding(内边距/内填充)，margin(外边距/外填充)，border(边框) 标准盒子模型(content-box) 标准盒子模型是w3c盒子模型，从上图可以看出width/height的计算规则是只包含content部分 IE盒子模型(border-box) 从上图可以看出IE盒子模型的width/height计算包含border，padding和content 只要在HTML文件顶部有doctype声明，浏览器就会使用w3c的标准盒子模型；如果没有声明，则不同浏览器会使用不同的盒子模型去加载，如IE使用IE盒子模型，Chrome和Firefox会使用w3c标准盒子模型 在CSS3中，我们可以自己定义盒子模型(box-sizing) box-sizing 有两个值，一个是content-box(默认标准模型)，另一个是border-box(IE盒子模型，也加边框模型) 2.行内元素和块级元素行内元素和块级元素的区别： 1.行内元素会在一条直线上排列，而块级元素占据一行，在垂直方向上排列。 2.一般情况下(HTML5之前)，行内元素只能包含文本和其他行内元素，而块级元素可以包含行内元素和块级元素 按照新的HTML规范，已经不按inline和block来区分元素类型了 替换元素与非替换元素 从元素本身特点来讲，元素分为替换元素和非替换元素 替换元素：浏览器根据元素属性来决定元素具体显示的内容。比如说浏览器会根据 img 标签的src来读取图片信息，根据 input 标签的type来决定是输入框还是按钮等。HTML中的 img ，input ， select ， textarea 等都是替换元素，因为这些元素没有实际内容，浏览器根据标签类型或属性来显示这些元素 非替换元素：HTML中多数元素都是不可替换元素，其内容直接显示在浏览器上。接下来就是重点了：1.块级元素width/height/margin/padding的设置都有效2.行内替换元素width/height/margin/padding的设置都有效3.行内非替换元素width/height的设置无效，一般用line-height控制行高(大部分行内元素都是行内非替换元素，如span,a,i,label等)；margin的左右设置有效，上下设置无效；padding的上下左右设置我认为其实都有效，但是由于行高没有发生变化，元素的位置只相对于左右变化，而上下没有变化。 3.定位(position) static: 静态定位，默认(没有定位) relative: 绝对定位，相对元素本身定位，也就是相对于它本该存在的位置(正常位置)定位，位置通过 left / right / top / bottom 确定 absolute: 相对定位，相对该元素第一个不是static定位的父元素定位，位置通过 left / right / top / bottom 确定 fixed: 固定定位，相对浏览器窗口定位，位置通过 left / right / top / bottom 确定 inherit: 继承，从父元素继承position定位 定位会脱离文档流，父元素计算高度的时候不会将其计算进去 4.浮动(float)浮动的特点 浮动元素不会遮住其它元素内容，但是会遮住非浮动元素的布局 浮动元素的父元素在对内容进行排版展示时会忽略浮动子元素的存在(脱离文档流) 浮动元素会自动变成块级元素 清除浮动的方法 父元素设置overflow:hidden 父元素设置height 父元素定义伪类 :after 父元素结尾处加一个空标签：clear both 父元素也设置浮动，但是需要设置宽度… 5.css常用布局","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jx-zyf.github.io/tags/HTML/"}]},{"title":"HTML&CSS基础知识（一）","slug":"HTML与CSS","date":"un55fin55","updated":"un22fin22","comments":true,"path":"/posts/e8a88825/","link":"","permalink":"https://jx-zyf.github.io/posts/e8a88825/","excerpt":"","text":"HTML&amp;CSS1.主要浏览器有哪些？内核分别是什么？主流浏览器及内核： (1)Chrome：Webkit (2)IE：Trident (3)Safari：Webkit (4)Firefox:Gecko (5)Opera:Presto 2.DoctypeDOCTYPE是用来声明文档类型和DTD(document type definition,文档类型定义)规范的 HTML5只有一种&lt;!DOCTYPE&gt;声明 &lt;!DOCTYPE html&gt; HTML5不基于 SGML，所以不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。注意：&lt;!DOCTYPE&gt;不是HTML标签，没有结束标签，不区分大小写 3.浏览器模式浏览器模式分两种：(1).标准模式(standards mode)：浏览器根据标准规约来渲染页面 以下情况浏览器会采用标准模式渲染： 给出了完整的DOCTYPE声明DOCTYPE声明了Strict DTDDOCTYPE声明了Transitional DTD和URI (2).混杂/怪异/兼容模式(quirks mode)：浏览器采用更宽松的，向后兼容的方式来渲染页面 以下情况浏览器会采用混杂模式渲染： DOCTYPE声明了Transitional DTD但未给出URIDOCTYPE声明不合法 DTD未给出DOCTYPE声明混杂模式下，浏览器会模仿旧浏览器的行为 4.页面引入CSS样式时，link和@import的区别 link属于XHTML标签，除了加载CSS外，还能用于定义RSS，定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS；页面加载时，link引入的样式会同时被加载；而@import引入的样式只有在页面加载完才会被加载import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 5.浏览器渲染原理挂上大佬的博客，讲的很详细 深度剖析浏览器渲染性能原理，你到底知道多少？文章作者：齐修_qixiuss","categories":[{"name":"coder","slug":"coder","permalink":"https://jx-zyf.github.io/categories/coder/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://jx-zyf.github.io/tags/HTML/"}]},{"title":"About Me","slug":"About","date":"un66fin66","updated":"un22fin22","comments":true,"path":"/posts/f0b34752/","link":"","permalink":"https://jx-zyf.github.io/posts/f0b34752/","excerpt":"","text":"林寻丶我的微博 我是 林寻丶 热爱生活，热爱生命喜欢音乐，喜欢篮球的热血boy motto","categories":[{"name":"about","slug":"about","permalink":"https://jx-zyf.github.io/categories/about/"}],"tags":[]},{"title":"2017 in ShenZhen","slug":"Mylife","date":"un66fin66","updated":"un22fin22","comments":true,"path":"/posts/293f0615/","link":"","permalink":"https://jx-zyf.github.io/posts/293f0615/","excerpt":"","text":"深圳群居生活中…","categories":[{"name":"Mylife","slug":"Mylife","permalink":"https://jx-zyf.github.io/categories/Mylife/"}],"tags":[]}]}